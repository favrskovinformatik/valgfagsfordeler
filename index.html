<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Valgfags-fordeler</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@stlite/mountable@0.39.0/build/stlite.css" />
  </head>
  <body>
    <div id="root"></div>
    <script src="https://cdn.jsdelivr.net/npm/@stlite/mountable@0.39.0/build/stlite.js"></script>
    <script>
      stlite.mount({
        requirements: ["pandas", "openpyxl"],
        entrypoint: "app.py",
        files: {
          "app.py": `
import streamlit as st
import pandas as pd
import io
import random

st.set_page_config(page_title="Valgfagsfordeling", layout="wide")

# --- FORSIDE / VEJLEDNING ---
st.title("üìñ Valgfagsfordeling")

st.info("""
### 1. Krav til Excel-filens format
* **Kolonner:** Filen SKAL indeholde kolonnerne **Id**, **Navn**, **Vf1**, **Vf2**, **Vf3** og **Fr.sprog**.
* **Niveauerne:** Genkendes p√• det sidste bogstav i fagets navn. **'A'** eller **'B'** placeres i **B√•nd 1, 2 eller 3**, mens **'C'** kan placeres i **alle 4 b√•nd**.

**Eksempel p√• dataformat i Excel:**
| Id | Navn | Vf1 | Vf2 | Vf3 | Fr.sprog |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 2p 23 | Jensen, Mette | <enA> | <tyFort.A> | <inC> | |
| 2q 08 | Petersen, Jonas | <iaB> | <psC> | | 24spA2 |

*Bem√¶rk: Valgfag st√•r typisk i vinkelparenteser <>. Tomme celler er ok. Fremmedsprog st√•r som tekst og holdnavnet skal v√¶re ens p√• tv√¶rs af klasser.*

* **Fremmedsprog & Fysik A (fyA):** Disse hold **splittes aldrig**.
* **Specialregler for ia, fi og in:** Disse hold m√• **aldrig** ligge i samme b√•nd. Dette g√¶lder ogs√• p√• tv√¶rs af niveauer (f.eks. m√• iaB og iaC ikke ligge i samme b√•nd).

### S√¶rlige funktioner
* **Klasse-optimering:** Efter alle elever er fordelt, fors√∏ger programmet at bytte elever indbyrdes mellem parallelhold, s√• man kommer p√• hold med flest mulige fra sin egen klasse.
* **Simulering:** Programmet k√∏rer op til 100 simuleringer for at finde den kombination, der giver 0 elever med uopfyldte √∏nsker.
""")

st.divider()

# --- SELVE PROGRAMMET ---
uploaded_file = st.file_uploader("Upload Excel-fil her", type=["xlsx"])

def clean_tag(val):
    if pd.isna(val) or str(val).strip() == "": return None
    return str(val).replace('<', '').replace('>', '').strip()

def get_base_fag(fag_navn):
    # Udtr√¶kker de f√∏rste to bogstaver for at gruppere iaB, iaC, inC osv.
    return fag_navn[:2].lower()

if uploaded_file:
    df = pd.read_excel(uploaded_file)
    oprindelige_elever = []
    fag_behov = {}
    
    for _, row in df.iterrows():
        v = [clean_tag(row.get('Vf1')), clean_tag(row.get('Vf2')), clean_tag(row.get('Vf3'))]
        sprog = clean_tag(row.get('Fr.sprog'))
        √∏nsker = [f for f in [sprog, v[0], v[1], v[2]] if f]
        klasse = str(row['Id'])[:2].lower()
        oprindelige_elever.append({"Id": row['Id'], "Navn": row['Navn'], "Klasse": klasse, "√ònsker": √∏nsker})
        for f in √∏nsker:
            fag_behov[f] = fag_behov.get(f, 0) + 1

    MAX_SIZE = 30

    def run_simulation():
        hold_pool = []
        sorted_fags = sorted(fag_behov.items(), key=lambda x: (any(s in x[0].lower() for s in ["ty","fr","sp"]) or "fya" in x[0].lower()), reverse=True)
        
        for fag, antal in sorted_fags:
            f_low = fag.lower()
            last_char = f_low[-1] if f_low else ""
            base = get_base_fag(fag)
            
            is_sprog_fya = any(s in f_low for s in ["ty", "fr", "sp"]) or "fya" in f_low
            is_c = (last_char == 'c') and not is_sprog_fya
            
            n_hold = 1 if is_sprog_fya else (antal // (MAX_SIZE + 1)) + 1
            
            for i in range(n_hold):
                mulige = [1, 2, 3, 4] if is_c else [1, 2, 3]
                hold_pool.append({
                    "fag": fag, 
                    "base": base,
                    "navn": f"{fag}_H{i+1}" if n_hold > 1 else fag,
                    "baand": random.choice(mulige), 
                    "elever": [], 
                    "max": 1000 if is_sprog_fya else MAX_SIZE,
                    "mulige_baand": mulige, 
                    "is_sprog_fya": is_sprog_fya,
                    "special_conflict": base in ["ia", "fi", "in"]
                })

        elever = [dict(e, Tildelt=[]) for e in oprindelige_elever]
        random.shuffle(elever)
        elever.sort(key=lambda x: any(s in "".join(x["√ònsker"]).lower() for s in ["ty","fr","sp"]), reverse=True)

        for e in elever:
            optagede_baand = {}
            for √∏nske in e["√ònsker"]:
                placeret = False
                relevante_hold = [h for h in hold_pool if h["fag"] == √∏nske]
                relevante_hold.sort(key=lambda x: len(x["elever"]))
                
                for h in relevante_hold:
                    # Tjek global b√•nd-konflikt for specialfag (ia, fi, in)
                    b√•nd_konflikt = False
                    if h["special_conflict"]:
                        if any(other["baand"] == h["baand"] and other["base"] == h["base"] and other["navn"] != h["navn"] for other in hold_pool):
                            b√•nd_konflikt = True
                    
                    if h["baand"] not in optagede_baand and not b√•nd_konflikt and len(h["elever"]) < h["max"]:
                        h["elever"].append(e)
                        optagede_baand[h["baand"]] = h
                        e["Tildelt"].append(√∏nske)
                        placeret = True
                        break
                
                if not placeret:
                    for h in relevante_hold:
                        for nyt_b in h["mulige_baand"]:
                            b√•nd_konflikt = False
                            if h["special_conflict"]:
                                if any(other["baand"] == nyt_b and other["base"] == h["base"] and other["navn"] != h["navn"] for other in hold_pool):
                                    b√•nd_konflikt = True
                            
                            if nyt_b not in optagede_baand and not b√•nd_konflikt and len(h["elever"]) < h["max"]:
                                h["baand"] = nyt_b
                                h["elever"].append(e)
                                optagede_baand[nyt_b] = h
                                e["Tildelt"].append(√∏nske)
                                placeret = True
                                break
                        if placeret: break
        
        mangler = sum(1 for e in elever if len(e["Tildelt"]) < len(e["√ònsker"]))
        return mangler, hold_pool, elever

    best_mangler = 999
    best_res = None
    with st.spinner('K√∏rer simuleringer...'):
        for i in range(100):
            m, h, e = run_simulation()
            if m < best_mangler:
                best_mangler = m
                best_res = (h, e)
            if best_mangler == 0: break

    final_hold, final_elever = best_res

    # KLASSE-OPTIMERING
    for fag_navn in fag_behov.keys():
        fagets_hold = [h for h in final_hold if h["fag"] == fag_navn and not h["is_sprog_fya"]]
        if len(fagets_hold) > 1:
            for _ in range(200):
                h1, h2 = random.sample(fagets_hold, 2)
                if h1["baand"] == h2["baand"]:
                    for i, e1 in enumerate(h1["elever"]):
                        for j, e2 in enumerate(h2["elever"]):
                            c1 = (sum(1 for x in h1["elever"] if x["Klasse"] == e1["Klasse"]) + 
                                  sum(1 for x in h2["elever"] if x["Klasse"] == e2["Klasse"]))
                            c2 = (sum(1 for x in h1["elever"] if x["Klasse"] == e2["Klasse"]) + 
                                  sum(1 for x in h2["elever"] if x["Klasse"] == e1["Klasse"]))
                            if c2 > c1:
                                h1["elever"][i], h2["elever"][j] = e2, e1

    if best_mangler == 0:
        st.success("‚úÖ Succes! Alle √∏nsker er opfyldt.")
    else:
        st.warning(f"‚ö†Ô∏è Resultat: {best_mangler} √∏nsker kunne ikke opfyldes.")

    output = io.BytesIO()
    with pd.ExcelWriter(output, engine='openpyxl') as writer:
        oversigt = []
        for h in final_hold:
            if h["elever"]:
                oversigt.append({"Hold": h["navn"], "B√•nd": h["baand"], "Antal elever": len(h["elever"])})
        pd.DataFrame(oversigt).sort_values(["B√•nd", "Hold"]).to_excel(writer, sheet_name='Oversigt_Hold', index=False)
        
        fejl = [{"Elev": f"{e['Navn']} ({e['Id']})", "Mangler": ", ".join(set(e['√ònsker'])-set(e['Tildelt']))} for e in final_elever if len(e['Tildelt']) < len(e['√ònsker'])]
        pd.DataFrame(fejl).to_excel(writer, sheet_name='Uopfyldte_√ònsker', index=False)

        for h in final_hold:
            if h["elever"]:
                navne = [f"{e['Navn']} ({e['Id']})" for e in h["elever"]]
                pd.DataFrame({"Navn": sorted(navne)}).to_excel(writer, sheet_name=h["navn"][:31], index=False)

    st.download_button("Hent f√¶rdig Excel-fil", output.getvalue(), "valgfagsfordeling.xlsx")
`
        }
      });
    </script>
  </body>
</html>
