<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Valgfags-fordeler</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@stlite/mountable@0.39.0/build/stlite.css" />
  </head>
  <body>
    <div id="root"></div>
    <script src="https://cdn.jsdelivr.net/npm/@stlite/mountable@0.39.0/build/stlite.js"></script>
    <script>
      stlite.mount({
        requirements: ["pandas", "openpyxl"],
        entrypoint: "app.py",
        files: {
          "app.py": `
import streamlit as st
import pandas as pd
import io
import random
import copy

st.set_page_config(page_title="Valgfagsfordeling", layout="wide")

# --- FORSIDE / VEJLEDNING ---
st.title("üìñ Valgfagsfordeling")

st.info("""
### 1. Krav til Excel-filens format
* **Kolonner:** Filen SKAL indeholde kolonnerne **Id**, **Navn**, **Vf1**, **Vf2**, **Vf3** og **Fr.sprog**.
* **Niveauerne:** Genkendes p√• det sidste bogstav i fagets navn. **'A'** eller **'B'** placeres i **B√•nd 1, 2 eller 3**, mens **'C'** kan placeres i **alle 4 b√•nd**.

**Eksempel p√• dataformat i Excel:**
| Id | Navn | Vf1 | Vf2 | Vf3 | Fr.sprog |
| :--- | :--- | :--- | :--- | :--- | :--- |
| 2p 23 | Jensen, Mette | <enA> | <tyFort.A> | <inC> | |
| 2q 08 | Petersen, Jonas | <iaB> | <psC> | | 24spA2 |

*Bem√¶rk: Valgfag st√•r typisk i vinkelparenteser <>. Tomme celler er ok. Fremmedsprog st√•r som tekst og holdnavnet skal v√¶re ens p√• tv√¶rs af klasser.*

* **Fremmedsprog & Fysik A (fyA):** Disse hold **splittes ikke**.
* **Specialregler for ia, fi og in:** Disse hold m√• **ikke** ligge i samme b√•nd.

### Funktionalitet
* **Klasse-optimering:** Efter alle elever er fordelt, fors√∏ger programmet at bytte elever indbyrdes mellem parallelhold, s√• man kommer p√• hold med flest mulige fra sin egen klasse.
* **Simulering:** Programmet k√∏rer op til 100 simuleringer for at finde den kombination, der giver 0 elever med uopfyldte √∏nsker.
""")

st.divider()

# --- SELVE PROGRAMMET ---
uploaded_file = st.file_uploader("Upload Excel-fil her", type=["xlsx"])

def clean_tag(val):
    if pd.isna(val) or str(val).strip() == "": return None
    return str(val).replace('<', '').replace('>', '').strip()

def get_base_fag(fag_navn):
    return fag_navn[:2].lower()

if uploaded_file:
    df = pd.read_excel(uploaded_file)
    oprindelige_elever = []
    fag_behov = {}
    
    for _, row in df.iterrows():
        v = [clean_tag(row.get('Vf1')), clean_tag(row.get('Vf2')), clean_tag(row.get('Vf3'))]
        sprog = clean_tag(row.get('Fr.sprog'))
        √∏nsker = [f for f in [sprog, v[0], v[1], v[2]] if f]
        klasse = str(row['Id'])[:2].lower()
        oprindelige_elever.append({"Id": row['Id'], "Navn": row['Navn'], "Klasse": klasse, "√ònsker": √∏nsker})
        for f in √∏nsker:
            fag_behov[f] = fag_behov.get(f, 0) + 1

    MAX_SIZE = 30

    def run_simulation():
        hold_pool = []
        sorted_fags = sorted(fag_behov.items(), key=lambda x: (any(s in x[0].lower() for s in ["ty","fr","sp"]) or "fya" in x[0].lower()), reverse=True)
        
        for fag, antal in sorted_fags:
            f_low = fag.lower()
            last_char = f_low[-1] if f_low else ""
            base = get_base_fag(fag)
            is_sprog_fya = any(s in f_low for s in ["ty", "fr", "sp"]) or "fya" in f_low
            is_c = (last_char == 'c') and not is_sprog_fya
            n_hold = 1 if is_sprog_fya else (antal // (MAX_SIZE + 1)) + 1
            
            for i in range(n_hold):
                mulige = [1, 2, 3, 4] if is_c else [1, 2, 3]
                hold_pool.append({
                    "fag": fag, "base": base, "navn": f"{fag}_H{i+1}" if n_hold > 1 else fag,
                    "baand": random.choice(mulige), "elever": [], 
                    "max": 1000 if is_sprog_fya else MAX_SIZE,
                    "mulige_baand": mulige, "is_sprog_fya": is_sprog_fya,
                    "special_conflict": base in ["ia", "fi", "in"]
                })

        # Sikrer helt friske data til hver simulering
        elever = [copy.deepcopy(e) for e in oprindelige_elever]
        for e in elever: e["Tildelt"] = []
        random.shuffle(elever)
        elever.sort(key=lambda x: any(s in "".join(x["√ònsker"]).lower() for s in ["ty","fr","sp"]), reverse=True)

        for e in elever:
            optagede_baand = {}
            for √∏nske in e["√ònsker"]:
                placeret = False
                relevante_hold = [h for h in hold_pool if h["fag"] == √∏nske]
                relevante_hold.sort(key=lambda x: len(x["elever"]))
                
                for h in relevante_hold:
                    b√•nd_konflikt = False
                    if h["special_conflict"]:
                        if any(other["baand"] == h["baand"] and other["base"] == h["base"] and other["navn"] != h["navn"] for other in hold_pool):
                            b√•nd_konflikt = True
                    
                    if h["baand"] not in optagede_baand and not b√•nd_konflikt and len(h["elever"]) < h["max"]:
                        # EKSTRA TJEK: Er elev allerede tilf√∏jet (ID tjek)?
                        if not any(el["Id"] == e["Id"] for el in h["elever"]):
                            h["elever"].append(e)
                            optagede_baand[h["baand"]] = h
                            e["Tildelt"].append(√∏nske)
                            placeret = True
                            break
                
                if not placeret:
                    for h in relevante_hold:
                        for nyt_b in h["mulige_baand"]:
                            b√•nd_konflikt = False
                            if h["special_conflict"]:
                                if any(other["baand"] == nyt_b and other["base"] == h["base"] and other["navn"] != h["navn"] for other in hold_pool):
                                    b√•nd_konflikt = True
                            
                            if nyt_b not in optagede_baand and not b√•nd_konflikt and len(h["elever"]) < h["max"]:
                                if not any(el["Id"] == e["Id"] for el in h["elever"]):
                                    h["baand"] = nyt_b
                                    h["elever"].append(e)
                                    optagede_baand[nyt_b] = h
                                    e["Tildelt"].append(√∏nske)
                                    placeret = True
                                    break
                        if placeret: break
        
        mangler = sum(1 for e in elever if len(e["Tildelt"]) < len(e["√ònsker"]))
        return mangler, hold_pool, elever

    best_mangler = 999
    best_res = None
    with st.spinner('K√∏rer simuleringer...'):
        for i in range(100):
            m, h, e = run_simulation()
            if m < best_mangler:
                best_mangler = m
                best_res = (h, e)
            if best_mangler == 0: break

    final_hold, final_elever = best_res

    # --- KLASSE-OPTIMERING MED DUBLET-STOP ---
    for fag_navn in fag_behov.keys():
        fagets_hold = [h for h in final_hold if h["fag"] == fag_navn and not h["is_sprog_fya"]]
        if len(fagets_hold) > 1:
            for _ in range(300):
                h1, h2 = random.sample(fagets_hold, 2)
                if h1["baand"] == h2["baand"] and h1["elever"] and h2["elever"]:
                    i = random.randrange(len(h1["elever"]))
                    j = random.randrange(len(h2["elever"]))
                    e1, e2 = h1["elever"][i], h2["elever"][j]
                    
                    c1 = (sum(1 for x in h1["elever"] if x["Klasse"] == e1["Klasse"]) + 
                          sum(1 for x in h2["elever"] if x["Klasse"] == e2["Klasse"]))
                    c2 = (sum(1 for x in h1["elever"] if x["Klasse"] == e2["Klasse"]) + 
                          sum(1 for x in h2["elever"] if x["Klasse"] == e1["Klasse"]))
                    
                    if c2 > c1:
                        # Vigtigt: Byt kun hvis det ikke skaber dubletter
                        if not any(x["Id"] == e2["Id"] for x in h1["elever"]) and not any(x["Id"] == e1["Id"] for x in h2["elever"]):
                            h1["elever"][i], h2["elever"][j] = e2, e1

    if best_mangler == 0:
        st.success("‚úÖ Succes! Alle √∏nsker er opfyldt.")
    else:
        st.warning(f"‚ö†Ô∏è Resultat: {best_mangler} √∏nsker kunne ikke opfyldes.")

    output = io.BytesIO()
    with pd.ExcelWriter(output, engine='openpyxl') as writer:
        # 1. FANEN: Oversigt_Hold (Renset for dubletter)
        oversigt = []
        for h in final_hold:
            seen_ids = set()
            clean_list = []
            for e in h["elever"]:
                if e["Id"] not in seen_ids:
                    clean_list.append(e)
                    seen_ids.add(e["Id"])
            h["elever"] = clean_list

            if h["elever"]:
                oversigt.append({"Hold": h["navn"], "B√•nd": h["baand"], "Antal elever": len(h["elever"])})
        
        pd.DataFrame(oversigt).sort_values(["B√•nd", "Hold"]).to_excel(writer, sheet_name='Oversigt_Hold', index=False)
        
        # 2. FANEN: Elev_Skemaer (Den nye oversigt du bad om)
        skema_data = []
        for e in final_elever:
            # Vi finder hvilke fag eleven har f√•et i hvert b√•nd
            # Vi kigger i final_hold for at se hvor eleven er placeret
            elev_fag = {1: "", 2: "", 3: "", 4: ""}
            for h in final_hold:
                if any(el["Id"] == e["Id"] for el in h["elever"]):
                    elev_fag[h["baand"]] = h["fag"]
            
            skema_data.append({
                "Id": e["Id"],
                "Navn": e["Navn"],
                "B√•nd 1": elev_fag[1],
                "B√•nd 2": elev_fag[2],
                "B√•nd 3": elev_fag[3],
                "B√•nd 4": elev_fag[4]
            })
        
        pd.DataFrame(skema_data).sort_values("Navn").to_excel(writer, sheet_name='Elev_Skemaer', index=False)

        # 3. FANEN: Uopfyldte_√ònsker
        fejl = [{"Elev": f"{e['Navn']} ({e['Id']})", "Mangler": ", ".join(set(e['√ònsker'])-set(e['Tildelt']))} for e in final_elever if len(e['Tildelt']) < len(e['√ònsker'])]
        pd.DataFrame(fejl).to_excel(writer, sheet_name='Uopfyldte_√ònsker', index=False)

        # 4. FANER: Individuelle Holdlister
        for h in final_hold:
            if h["elever"]:
                navne = [f"{e['Navn']} ({e['Id']})" for e in h["elever"]]
                pd.DataFrame({"Navn": sorted(navne)}).to_excel(writer, sheet_name=h["navn"][:31], index=False)

    st.download_button("Hent f√¶rdig Excel-fil", output.getvalue(), "valgfagsfordeling.xlsx")
`
        }
      });
    </script>
  </body>
</html>
